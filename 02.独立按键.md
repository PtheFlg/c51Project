
# 1. 按键原理

按键座两端有导线连接，中间断开，按键头里面也有导线，按键被下后，按键中的导线和按键座中的导线连通。看原理图：

![image.png](https://gitee.com/pthef/imgrepo/raw/master/20250128155021.png)

GND 是接地，可以理解为负极，0V，P30 - P33 正常情况下是 高电平，按钮没按下时，P端和 GND端未连接。

如果 K1 按钮按下，GND 会连通 P31 引脚，相当于 P31 接地了，P31 就会变成 0V，我们要做的就是检测 P30 - P31 四个引脚什么时候变为 0，就说明按钮按下。

# 2. 位检测

P30 - P33 引脚对应 P3 寄存器，只需要用到 P3 寄存器的低4 位即可，需要检测低4位哪一位变成了 0。
如果我们直接判断：`if(P3 == 0xFE) // 1111 1110` 有时确实可以知道 P30 引脚变为0，K2 按钮被按下了，但是如果 P3 寄存器的高4位被其他部件使用了，P3变成了 1010 1110，那显然判断就不通过了，我们需要直接判断寄存器中的某一位。

## 2.1 按位寻址

手册里面对于某些寄存器的描述会有一句：可按位寻址：

![image.png](https://gitee.com/pthef/imgrepo/raw/master/20250128160203.png)

就是说，寄存器里的每一位可能都很常用，所以给 TCON 寄存器里面的每一位又都起了名，比如我们想设置 TCON 的 TF1 位，我们除了可以 `TCON = 0x80` 对寄存器整体赋值，也可以直接 `TF1 = 1;`。

实际上很多时候对寄存器整体赋值并不合理，比如 TCON 寄存器，我们只需要改变 TF1 的值，直接执行 TCON = 0x80 就会破坏 TCON 其他位。

## 2.2 按位判断

如果不可位寻址，就可以通过 & 运算来实现对位的单独判断。若我们想判断 TCON 的 B0位，可以执行： `if(TCON & 0x01)`。想判断 B2 位，就 `if(TCON & 0x04)`。

其实就是：
```
判断 0 位：
1010 0011 & 0000 0001 = 0000 0001 非 0

判断 3 位：
1010 0011 & 0000 1000 = 0000 0000 为 0

判断 5 位：
1010 0011 & 0010 0000 = 0010 0000 非 0

判断 i 位：
1010 0011 & ( 0000 0001 << i ) 非 0 ？ 非 0 则 i 位 = 1，否则 = 0
```

## 2.3 特殊位标记

我们可以自己给一些特殊的位定义别名，通过 sbit 关键字（special bit）：

```c
sbit KEY_0 P3^1
sbit KEY_1 P3^0
sbit KEY_2 P3^2
sbit KEY_3 P3^3
```

sbit 后面写的是自己定义的别名，后面 P3^0 就是 P3 寄存器的 第 0 位，通过 `P3 ^ x` 来单独标记第 x 位，注意， `^` 虽然是亦或运算符，但是这里并不代表亦或，仅仅代表某一位。

# 3. 代码实现

## 3.1 按下检测

我们需要用到 P3 的低 4 位，在 REGX52.H 头文件中，已经帮我们定义了 sbit：
```c
sbit P3_0 P3^0
sbit P3_1 P3^1
....
```
或者我们可以自己定义一遍：

```c
#include <REGX52.H>

sbit K0 P3^1
sbit K1 P3^0
sbit K2 P3^2
sbit K3 P3^3

void main() {

	while(1) {
		if(!K0) {}  // 按钮 K0 按下
		if(!K1) {}  // 按钮 K1 按下
		if(!K2) {}  // 按钮 K2 按下
		if(!K3) {}  // 按钮 K3 按下
	}
}
```

可以实现最简单的检测，只要按钮被下，就会一直被检测到，但是无法检测按下的次数，一直按着按钮，引脚电平始终是 0，就会一直在对应代码块内不停的循环，下一步要检测按下一次按钮。

## 3.2 弹起检测

检测按钮被按下一次的流程：

1. 引脚电平为 0，说明按钮刚被按下
2. 延时一小段时间，等待电平稳定。引脚和 GND 一连接，引脚上的电平会有短暂的抖动，需要等一下。
3. 等待引脚电平返回 高，这是说明按钮弹起
4. 等待电平稳定
5. 返回，判定完成

和上面的区别就是，上面是判定按钮持续按下，这里是判定按钮按下后弹起。

```c
#define BYTE unsigned char

/**
	返回按钮号 1 2 3 4
	K0 K1 K2 K3 是上面 sbit 出来的 P3 低4位的别名
*/
BYTE singleKey() {
	BYTE i = 0;
	if(!K0) {
		delay(10);  while(!K0);  delay(10);  i = 1;
	}
	if(!K1) {
		delay(10);  while(!K1);  delay(10);  i = 2;
	}
	if(!K2) {
		delay(10);  while(!K2);  delay(10);  i = 3;
	}
	if(!K3) {
		delay(10);  while(!K3);  delay(10);  i = 4;
	}
	return i;
}
```
这里我们重复检测了，依次检测 K0 到 K3，会不会我们先按下 K0 再 按下 K1，K1 就把 K0 刷掉了？其实不太可能，这个检测代码在死循环中，检测速度极快，人手估计很难在十几微秒内按下多个按键把。

主函数：

```c
void main() {
	BYTE key = 0;
	while(1) {
		key = singleKey();
	}
}
```

主函数中一直死循环检测，只要我们按下并松开按键，singleKey 函数就可以检测到并将按键的编号返回给主函数的 key。

