

# 1. 单片机

单片机是啥玩意？单片机指的就是开发版中间那一长条，里面有一个特别小的芯片，里面包含了 ROM，RAM，CPU 等等必须要的器件，然后外面用外壳包上，那个其实就是单片机。

开发版，就是在一个板子上加上各种各样的薄块，比如 LED，独立键盘，矩阵键盘等等，实际上就是给我们熟悉硬件学习用的。

# 2. 单片机的引脚

C51 单片机里面有40个 IO 引脚，或者叫 IO 接口，无所谓一个意思。所有的部件都是围绕这40个引脚展开的，所以我们操作开发版上的部件，归根到底就是在操作引脚的电平变化，或者根据引脚的电平来判断部件是否被触发。

后面，就正式开始操作单片机，从点亮一个 LED 开始。

# 3. 点亮一个 LED

操作部件就是在根据部件特性来操作引脚的电平变化，首先就要看部件的原理图：

## 3.1 LED 模块原理图

![](https://gitee.com/pthef/imgrepo/raw/master/20250128145536.png)

图中，VCC 指电源，大概会给一 5V 电压，8个绿的就是 LED，三角段是正极，竖线端是负极，后面 RP 就是电阻，最右边的 P20 - P27 是引脚。8个引脚从单片机出发。也就是单片机的 P20 - P27 引脚直接接到了 LED 模块上。

想让 D1 亮的话，就得让电路流过 LED，具体做法就是 VCC 会给一个 高电平，然后 P20 我们手动给他一个低电平 0 V，这样的话正极 5V 负极 0V 就可以流通 D1，D1 就能亮了。

问题就转变为：如果给 P20 端一个低电平。

## 3.2  寄存器

单片机总共有 40个 IO 接口，采用 8个一组的方式，给 40 个引脚连到了5个寄存器上，具体得去 STC89Cxx.pdf 那个手册里面看：

![image.png](https://gitee.com/pthef/imgrepo/raw/master/20250128151001.png)

根据手册里的全部寄存器表，P20 - P27 引脚对应的是 P2 寄存器，P2 寄存器（8位）的 0 - 7 位救队赢了 P20 - P27。

如果我们在程序中赋值 `P2 = 0xFE; // 1111 1110` 那就相当于给 P20 引脚一个低电平（0是低电平，1是高电平），就可以接通 LED 的 D1。

<font color = 'red'>注意，往后几乎所有的操作，都是在操作寄存器，通过赋值寄存器来间接实现引脚的电平变化。</font>

## 3.3 程序实现

用 Keil 5 新建一个工程，group 里创建一个 `main.c` 源文件：

```c
#include <REGX52.H>

void main() {
	while(1){
		P2 = 0xFE; // 1111 1110
	}
}
```
首先，`REGX52.H` 就是 51单片机的头文件，当然这个文件可能因为买的单片机不同而不同，头文件里就定义了 P2 寄存器。

主函数中写个死循环，因为把程序烧录进单片机后，单片机就会一直循环执行这个程序，为了避免程序太短执行完以后单片机循环，我们干脆就让程序内循环了，单片机不至于重复执行完整程序。

循环内，直接给 P2 寄存器赋值，让 P2 的 0 位为0，就可实现第一个 LED 发光。

## 3.4 LED 定时闪烁

windows 中写 C 语言可能会有 sleep 函数用于程序休眠一段时间，以达到定时的效果。但是单片机中没有这个函数，就需要用一种更原始的方法来实现延时：

```c
void delay1ms() //@12.000MHz
{
	unsigned char i, j;
	i = 2;
	j = 239;
	do{
		while (--j);
	} while (--i);
}
```
这个函数通过执行一系列没啥意义的代码来实现延时 1ms，具体就是通过时钟周期来机器周期来推算执行时间。

比如芯片的时钟频率是 12MHz，然后12个时钟周期是一个机器周期，也就是 1s 有 1M 个机器周期，则 一个 机器周期 就是 1us。然后通过推算执行多少个指令可以消耗 1K 个机器周期来实现延时 1ms。

根据这个代码，我们就可以写出延时 x毫秒 的函数：

```c
void delay(int xms) //@12.000MHz
{
	unsigned char i, j;
	do{
		i = 2;
		j = 239;
		do{
			while (--j);
		} while (--i);
	}while(--xms);
}
```

然后借用这个函数实现 LED 闪烁：

```c
void main() {
	while(1) {
		P2 = 0xFE;   // 1111 1110
		delay(300);
		P2 = 0xFF;   // 1111 1111
		delay(300);
	}
}
```

## 3.5 LED 流水灯

实现 LED 从 D1 依次亮岛 D8，实现思路很简单：P2 从`0xFE (1111 1110)` 变到 `ox7F(0111 1111)`,然后再变回 0xFE 即可。可以看出就是8位数里的 0 一次性往左移动，末尾补1 即可。

```c
void main() {
	P2 = 0xFE;
	while(1) {
		if(P2 == 0x7F){
			P2 = 0xFE;
		} else {
			P2 = (P2 << 1) + 0x01;
		}
	}
}
```

或者可以采用取反操作，`P2 = 0xFE(1111 1110); ~P2 = 0x01(0000 0001)`，那就转化成了让 1 不停的左移，移到边界再重制。

```c
void main() {
	unsigned char i = 0x01;
	while(1) {
		P2 = ~i;
		if(P2 == 0x80) {
			i = 0x01;
		} else {
			i = i << 1;
		}
	}
}
```

这里有个大坑：<font color = 'red'>函数中局部变量，必须放在开头，只要一开始操作寄存器，就认为程序正式开始执行，就不再记录局部变量</font>。



