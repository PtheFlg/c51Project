
# 1. 数码管结构

数码管就是那种，八个灯构成一个 ‘8’ 字形的结构：

![image.png](https://gitee.com/pthef/imgrepo/raw/master/20250128180504.png)

一个八字型里面有 7 个横，外加后面一个点，所有至少需要8个引脚操作一个数码管的8个灯，然后这个数码管组有4个，有需要额外的四个引脚来控制不同的数码管段。

## 1.1 原理图

看看开发版提供的数码管原理图：

![image.png](https://gitee.com/pthef/imgrepo/raw/master/20250128180803.png)

看图发现，所有数码管的相同边全都连到同一个引脚上，比如 a 边，8个数码管的 a 边，全部连接到了 P00 引脚，这就导致，我们给P00一个高电平，LED1 - LED8 全部是低电平（8个数码管全部开启），会导致所有数码管的a边被点亮，这就导致：<font color = 'red'>在一个时刻，一组数码管只能显示一个内容，不可能并行的显示多个内容</font>。

想要不同数码管显示不同数字，就需要用到 **并发**，宏观上看同一时间不同数码管显示不同内容，微观上看，其实是不同数码管轮流的显示内容，然后快速切换，让我们以为是显示不同内容。

# 2. 74HC138 译码器

这个学计算机组成原理的提到过译码器，比如内存在同一时间只能选通一行来传出数据，总共有 8 行，那就可以只用三根线来控制八行，3选8，就叫 38 译码器。

这里的情况类似，8个数码管，但是在一个时刻内，只需要选通一个数码管进行显示。比如要显示 123，那就先选通第一个数码管显示 1，然后快速的切换到第二个数码管显示2，再切换到第三个数码管显示3，快速的切换，就会看起来显示的是 123。所以，就可以使用 138 译码器，用 3 个线，来选中8条线中的某一条（只能是一条）。

![image.png](https://gitee.com/pthef/imgrepo/raw/master/20250128182445.png)

芯片上的 VCC 和 GND 负责给芯片单独供电，`P24 P23 P22` 三位二进制数可以表示8个状态，来选通 Y0 - Y7。图中 Y0 - Y7 上面有条横线，代表取低电平。

具体例子就是：我们让 `P24 = 1; P23 = 0; P22 = 1;`，三位二进制表示十进制数 5，就会选通 Y5，给 Y5 输出低电平，其他高电平，输出 `1111 1011`，Y5 对应 LED6，则 数码管6 被选中，然后通过给 P00 - P07 赋值，让数码管6显示内容。

## 2.1 寄存器按位修改

写一个函数，传入一个小于 8 的十进制数，来操作 P22 - P24，传出 Y0 - Y7 其中一个低电平，传出部分肯定是译码器实现，我们只要实现如何通过十进制来操作 P22 - P24 即可。

前面独立键盘说了如何只判断寄存器其中的一位，这里说说如何改寄存器中的某几位：

1. 将要改的几位置 0，使用 & 操作：
```c
P2 = 0xFE;   // 1111 1110

P2 = P2 & E3;  // 1110 1110 & 1110 0011 = 1110 0010
```
让需要被修改的寄存器 & 上数字 H，H 中只有我们要改的几位是 0，其他都是 1，这样 & 出来的结果，除了需要被改的位变成了 0 ，其他位仍然和 寄存器以前的值一样。

2. 用 ｜ 运算修改这几位，假如 `P2 = 1111 1110 0xFE`，P22 - P24 置 0 后 变成：`P2 = P2 & 1110 0011 (0xE3); P2 变成 1110 0010 (0xE2)`，我们想让 P24 P23 P22 变成 110，对应十进制 6，选通 Y6（LED7）：
```c
P2 = 0xE2;   // 1110 0010

P2 = P2 | 0x1A;  // 1110 0010 | 000 110 00 = 1111 1010
```
让 置 0 后的寄存器，｜ 上 H，要改哪几位就在 H 中的对应位写，H 的其他位置都是 0.

总结：

给一个寄存器 R，位分别是 Sn - S0，我们想改 x1，x2 位置，则：

```c
R = R & (1 1 ...x1:0 ..1.. X2:0 ... 1) // 对应位变 0
R = R | (0 0 ... x1 ...0..  x2  ... 0) // 对应位修改
```

## 2.2 段选函数

函数实现：

```c
// 传入要选通 Yi，0 <= i <= 7
void selectLED(BYTE i) {
	P2 = P2 & 0xE3; // 1110 0011 = 111 000 11 中间要改的三位为 0，& 实现置 0

	// i 是个3bit 的十进制数，要把这个写到 P2 的 4 3 2 位上
	// 就需要将 i 左移两位，移到 4 3 2 位上，其他位是 0
	i = i << 2;

	// 然后通过 ｜ 上一个除了修改位其他都是 0 的数，实现修改
	P2 = P2 | i;
}
```

通过这个函数修改了 P2 寄存器后，138 译码器就会自动根据 4 3 2 位的值进行段选，输出 Yi 为低电平。

# 3. 数码管显示

## 3.1 数码管显示一个数字

根据原理图可以看出，一个数码管的灯号从最上面开始顺时针数分别是 a b c d e f g 以及后面的点 dp，这 8 个灯又依次按顺序连接到 P00 - P07 引脚，想要让一个数码管显示，只需要 先给 P24 P23 P22 实现段选，然后给 P0 （包含 P00 - P07引脚）一个值，即可显示。

比如我们想让第八个数码管（最左边的那个）显示 0，则：

```c
void main() {
	while(1) {
		selectLED(7); // 给 Y7 一个低电平，使 LED8 接通
		P0 = 0x3F; // 0011 1111 只有 P0 的 6 7 位给 0，相当于 正极 0，负极 LED8 0，
		// 则 LED8 中的灯 g 和 dp 不亮，其余都亮，显示出来的就是 0
	}
}
```

## 3.2 数码管动态显示多位数字

通过循环，一次让每一个数码管都显示一位数字，每个数码管快速闪烁，看起来就是显示了一个多位数字：

```c
#include <REGX52.H>
#define BYTE unsigned char

// 数码管显示函数
// i: 让哪个数码管显示，_data: 显示什么内容（只能显示数字，0 - f，也就是 _data <= 15）
void Nixie(BYTE i, _data) {
	// 段选，让哪个数码管显示数字，i 小于 8
	selectLED(i);

	// 显示：数码管显示一个数字需要给 a - dp 的值都是固定的，
	// 这里提前写好一个数组，nixie_number[i] 就是 数码管显示 i 需要给 P0 的值
	P0 = nixie_number[_data];

	// 让数码管显示 5ms
	delay(5);

	// 清空 P0
	P0 = 0x00;
}

void main() {
	while(1) {

		// 依次让 7 6 5 号数码管分别显 1 2 3，实现显示 123
		Nixie(7, 1);
		Nixie(6, 2);
		Nixie(5, 3);
	}

}
```

我们显示多位数字 123 的过程是：段选7 - 显示 1 - 段选 6 - 显示 2 - 段选 5 - 显示 3。

这样的话写出来会发现闪烁，因为我们段选 6 以后，P0 寄存器暂时还没改过来，数码管6 就会显示数码管7 刚刚显示的数字 1，然后再变成显示2，这就回导致闪烁。

办法就是在数码管显示函数中的结尾，将寄存器 P0 清空，在下一次段选开头，就不会显示前一位数字。