# 1. DS1302 芯片

这个芯片可以实现时钟功能，芯片外接了一个晶振，可以更精准的实现 Timer 的功能，有些时钟芯片还内置了一个电源，当整个系统接电时，用外部电源，同时给内置电源充电，断电后使用内置电源，实现不停的计时。

DS1302 芯片内部有年月日时分秒星期对应的寄存器，同时可以自动实现平闰年，2月天数的优化。

芯片有多个寄存器，可以通过读不同的寄存器来实现读时间，也可以写入寄存器指定时间，所以这个芯片的协议比 74HC595 要复杂点，需要向芯片发送特定格式的消息。

# 2. 开发版原理图

开发版原理图中的 DS1302 连接情况如下：

![image.png](https://gitee.com/pthef/imgrepo/raw/master/20250201152830.png)

芯片外接了一个晶振，然后 P36 34 35 连接到芯片的 SCLK，IO，CE 接口。

![image.png](https://gitee.com/pthef/imgrepo/raw/master/20250201153018.png)

详细的结构图，晶振给实时时钟提供一个稳定的 1Hz 频率实现时钟 + 1，CE 其实就是片选信号，只有 CE 为 高电平时，芯片才允许读写。IO 接受单片机发送过来的指令，然后根据命令控制逻辑，判断是继续等待输入数据并写入寄存器，还是将寄存器写到 IO 口返回给单片机。

# 3. 芯片交互

## 3.1 读写命令字

前面的74HC595 芯片只有一个功能：串行转并行，所以不需要这个，直接通过 SER 写入数据，芯片就会自动工作。但是 DS1302 芯片的功能不为1，可以写，可以读，就需要在交互开始时，向芯片写入命令字（其实就是指令），告诉芯片，接下来是要你给我返回数据，还是等着我给你写。

![image.png](https://gitee.com/pthef/imgrepo/raw/master/20250201153652.png)

格式如下：

- B7：始终为 1
- B6：指定后面要操作的是 CK 日历，还是 RAM 寄存器。CK 模式我没用过，我也不知道 CK 是干哈的。
- B5 - B1 ：5 位二进制，指定接下来要操作哪个 RAM，根据前面结构图，芯片里有 31 个寄存器，5bit 够了。
- B0：要读还是要写，1 = 读，0 = 写

## 3.2 传输时序

命令字有了，如何将命令字传入芯片？以及如何读取 芯片传来的数据？

### 3.2.1 写入时序

![image.png](https://gitee.com/pthef/imgrepo/raw/master/20250201154236.png)

首先片选线在读写期间一直是 1。

IO 用于传输数据，将命令字从 <font color = 'red'>低位到高位</font> 依次写到 IO 口上。

IO 口每写一位数据，都需要将 SCLK 拉高，通知 芯片赶紧接收这位数据，然后重新拉低 SCLK，再将下一位数据放到 IO 口上，重复 8 次，将整个 8 位命令字传入到芯片中。

如果是写指令的话，命令字最后一位是 0（但是传输的时候这位先放到 IO 上），同时指令字的 A4 - A0指定要写入的寄存器，在传完指令字后，紧接开始传入一个字节，同样是从低到高，每写入一位后，将 SCLK 拉高，让芯片读，然后拉低，重复八次。

总结一下就是：<font color = 'red'> DS1302 芯片在 SCLK 时钟的上升沿读入数据（芯片读入，不是单片机读入）。</font>所以单片机写一位，就拉高一次 SCLK。

### 3.2.2 读取时序

![image.png](https://gitee.com/pthef/imgrepo/raw/master/20250201154217.png)

一上来和前面一样，毕竟还是写入一个指令字，写入一位拉高一次时钟。但是指令字有区别，要读的话，指令字的最后一位是 1。

然后开始读区，看时序图，最后一次写入时，单片机先将 1 写到 IO 上，然后拉高 SCLK ，芯片读入完整指令字，然后紧接着在 SCLK 的下降沿，芯片就开始传出数据，单片机就需要开始读 IO 口。

额外提一句，这个 SCLK 在读取的时候仍旧是单片机控制，单片机将时钟拉低，芯片一看时钟低电平，就会将要发送的数据的低位写到 IO 口上，单片机就需要从 IO 口上读出数据。然后拉高时钟再拉低，读取下一位。

## 3.3 寄存器

![image.png](https://gitee.com/pthef/imgrepo/raw/master/20250201160046.png)

最常用的就这几个寄存器，分别是 秒、分钟、小时、日、月、星期、年、写保护。

前面的 READ 和 WRITE 就是操作这几个寄存器时需要用的指令字。

# 4. 代码实现

根据前面的时序，需要实现这几个功能：读字节，写字节，设置时间，读取时间。

## 4.1 写字节

这个最好写，因为时序始终都是在一个：放 IO，拉高 SCLK，重新拉低 SCLK：

```c
#define BYTE unsigned char

sbit DS1302_CE = P3^5;
sbit DS1302_IO = P3^4;
sbit DS1302_SCK = P3^6;

// 写入字节，cmd：指令字，要写哪个寄存器，_data：写入的实际字节
void DS1302_writeByte(BYTE cmd, BYTE _data) {
	BYTE i = 0;

	// 片选
	DS1302_CE = 1; 
	
	//DS1302_SCK = 0;

	for(; i < 8; i++) {
		// 从低到高取位
		DS1302_IO = cmd & (0x01 << i);

		// 给时钟上升沿，让芯片取走 IO 数据
		DS1302_SCK = 1;
		DS1302_SCK = 0;
	}

	for(i = 0; i < 8; i++) {
		DS1302_IO = _data & (0x01 << i);
		DS1302_SCK = 1;
		DS1302_SCK = 0;
	}

	DS1302_CE = 0;
}
```

和时序一一对应，很简单。指令的话外面设宏定义，因为读写时间寄存器的各个指令都是固定的。

## 4.2 读字节

这个会麻烦一点，因为中间过渡的时候在同一个时钟周期内，上升沿写，下降沿读，需要考虑好这个时序。

```c
BYTE DS1302_readByte(BYTE cmd) {
	BYTE i = 0;
	BYTE rec = 0x00;
	
	DS1302_CE = 1;

	// 写入命令字
	for(; i < 8; i++) {
		DS1302_IO = cmd & (0x01 << i);

		DS1302_SCK = 0;
		DS1302_SCK = 1;
	}

	// 读取寄存器
	for(i = 0; i < 8; i++) {

		DS1302_SCK = 1;
		DS1302_SCK = 0;

		// 如果取到 1，就给对应位置 1
		if(DS1302_IO) {
			rec = rec | (0x01 << i);
		}
		// 这种写法不知道行不行
		// rec = rec | (DS1302_IO << i);
	}

	DS1302_IO = 0;
	DS1302_CE = 0;

	return rec;
}
```

在发送指令字的时候把 SCK 拉高拉低的顺序调整一下，先将 SCK = 0，然后 SCK = 1，是为了和下面的读取时序对应。写指令字写完以后 SCK 停留在 1，然后在读取周期中接上 1，然后拉低到 0，读取 IO 口数据，然后循环回去执行 DS1302_SCK = 1，再 拉低，读下一位数据。