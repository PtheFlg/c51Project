
# 1. 定时器概述

之前我们要延迟使用 delay 函数，通过执行一系列空操作实现延迟一段时间。但是这种延迟的弊端就是延迟期间也会占用 CPU，如果我们延迟 2000ms，则 2S 内cpu会一直执行延迟的空操作，不会执行其他的操作，就会阻塞整个程序，不利于程序性能。

定时器就是 CPU 内部的一种定时机构，借助晶震实现定时的自增，自增到一定程度后发出中断，CPU 响应中断。实现延迟的效果，同时不会阻塞整个程序。

# 2. 中断系统

先复习一下计算机组成原理的中断：外部设备向 CPU 发出中断请求，CPU 在执行完一条指令后，开启中断响应周期。

如果 CPU 处于开中断，允许中断进入，则在中断响应周期中，CPU 会中断判优，根据中断优先级来判断先响应那个中断，将当前 PC 压栈保存断电，然后根据中断类型号找到中断向量，再将中断向量送入 PC 程序寄存器（中断隐指令）。所以在单片机中如何实现或者开启这些功能？

## 2.1 中断系统结构

先看看中断系统的结构：

![image.png](https://gitee.com/pthef/imgrepo/raw/master/20250131145655.png)

图里描述的就是开关和寄存器的对应关系，比如：

Timer0 计时器0 发出中断，开始往右传，ET0 开关闭合且 EA 开关闭合，TF0 中断才可以传入到中断优先级处理机构，然后根据 PX0H 和 PX0 开关的情况（00 01 10 11）被传入不同的优先级队列，等待 CPU 处理。

已知控制单片机归根到底就是在控制寄存器，通过给寄存器中某些位 1 / 0 实现功能。这里同理，其实每一个开关就是对应了一个寄存器的位，通过制定寄存器为 1 让开关闭合，为 0 让开关打开。

## 2.2 中断寄存器

### 2.2.1 中断允许寄存器

![image.png](https://gitee.com/pthef/imgrepo/raw/master/20250131145900.png)

IE（Interrupt Enable）可以说是最常用最重要的一个寄存器，用来控制整个单片机是否开启中断系统 和 其他部件是否允许提交中断。

- EA：Enable All，开启所有中断，允许中断
- ET2/1/0：Enable Timer 2 / 1 / 0，是否允许计时器中断
- ES：Enable Serial，允许串口中断（后面会学）
- EX2/1/0：Enable X 不知道 X 是啥，允许外部设备2 / 1 / 0中断

对应到结构图里，我们想让 Timer0 开启中断，首先需要让 IE 的第 7 位 为 1（IE寄存器可以按位寻址，直接 EA = 1 即可），打开整个中断的开关，再让 `ET0 = 1` ，中断信号才能传入中断优先级中。

### 2.2.2 辅助中断控制寄存器

![image.png](https://gitee.com/pthef/imgrepo/raw/master/20250131152133.png)

这个寄存器主要用来控制外部中断 2 / 3 的参数：

- PX3/2：中断优先级
- EX3/2：是否允许这个外部中断
- IE3/2：外部中断位，当 IE* = 1 时，代表有中断传入，可被硬件自动清 0
- IT3/2：触发中断方式，1 = 下降沿，0 = 低电平

这个寄存器其实不太重要，因为到现在我还没用过外部中断，但是可以结合图看看，INT0 触发中断，先甭管第一个开关，总之会把中断给 IE0 位，虽然上面这个 XICON 寄存器里面没有 IE0 只有 IE3/2，但是作用一样，就是外部中断0的中断位。

当 IE0 = 1 时，中断开始向右传递，通过 EX0 = 1，EA = 1，允许 INT0 提出中断，允许全部中断，将中断传入判优机构，再通过 PX0 和 PX0H 将中断传入响应的优先级队列。

## 2.3 中断处理函数

用 C 语言编程，可以自定义一个中断处理函数。每个中断源都有一个中断号，语法如下：

```c
// 中断 x 对应的中断函数
void interrupt_routine() interrupt x {
	// 中断处理逻辑
}

```
手册中说 中断号 == 查询次序，则：

![image.png](https://gitee.com/pthef/imgrepo/raw/master/20250131153613.png)

可知，我们要定义 Timer0 的中断处理函数：
```c
void Timer0_routine() interrupt 1 {
	// ...
}
```

# 3. 计数器

一般的 C51 单片机都有两个计时器，Timer0 和 Timer1，先看看计数器的原理：

## 3.1 计数器原理

![image.png](https://gitee.com/pthef/imgrepo/raw/master/20250131154053.png)

这个是计数器在 模式一（16位定时器）下的工作原理，其他模式也都一个道理：

1. 左边 SYSclk 就是晶振，会按照固定频率发出一个脉冲，假如这个频率是 12MHz（实际不一定是，我这个单片机好像是 11.0592MHz）
2. 如果 MCU 工作在 12T 模式下，那就是 每12 个脉冲记一次数，也就是给计数器 + 1。MCU 频率是 12MHz ，12 个周期 + 1，则 +1 的频率是 1MHz，也就是一个 +1 周期 1us。
3. TL0 和 TH0 就是计数器本体，16位，每次 + 1 都是在这 16bit 中 + 1，一直加，加到 16位计数器满了溢出，将 TF0 （Timer Flag）置 1，随后发出中断请求。

## 3.2 计数器相关寄存器

### 3.2.1 计数器控制寄存器

![image.png](https://gitee.com/pthef/imgrepo/raw/master/20250131155134.png)

Timer Control 寄存器：

- TF1/0：Timer Flag 中断标志位，根据原理图，当 TH & TL 16位寄存器溢出时，Timer Flag = 1，提交中断，响应后由硬件刷新 TF（也可以软件刷新）
- TR1/0：Timer Ready 计时器开启，这个和 ET0 和 ET1 区分一下，ET 位在 IE 寄存器中，用于控制 Timer 是否可以提交中断，TR 是控制计时器是否可用。
- IE0/1 + IT0/1：前面说过了，用于外部设备的中断标记和中断方式

如果要启用计时器0，需要 `TR0 = 1` 开始 Timer0.

### 3.2.2  计数器工作模式寄存器

![image.png](https://gitee.com/pthef/imgrepo/raw/master/20250131155957.png)

Timer Mode 寄存器：

- GATE：看眼原理图，如果 Gate = 1，则 Timer 是否开启由 INT1 和 TR0 共同控制，只有在 INT1 = 1 & TR0 = 1 时，Timer0才启用。
- C/T：为 1 时是 Counter 模式，为 0 时是 Timer 模式，看原理图，counter 模式下 + 1 频率将不再由 SYSclk 晶振提供，而是由外部的 Pin 提供。
- M1 + M0：定时器模式

定时器总共有 4 种模式：M1 M0 = 00 01 10 11，区别就是 TH0 和 TL0 用到了几位以及进位方式，大部分情况下用的都是模式1，16位模式。

## 3.3 16位定时器模式

这个模式的原理图就是前面那个原理图：

计数寄存器是 TH0 （高8位）和 TL0（低8位），两个寄存器构成一个 16 位数，+1 往这个 16位数中加，16位最大是 65535，每 + 1 是 1us，如果 TH0 和 TL0 是 0 的话，需要将 65535 加满溢出，经过 65ms 才能发出一次中断。

## 3.4 实现定时

前面已经知道，16位模式下，什么是否发出中断，取决于 TH0 TL0 什么是否加满。

如果我们想每隔 1ms 中断一次，先给 TH TL 一个初值 64535，然后每 1us 执行一次 +1，加到 65535 时正好 + 了 1000 次耗时 1000us = 1ms，随后 TH 和 TL 溢出，发出中断。然后在中断函数中将 TH TL 重新设回 64535，即可实现每隔 1ms 发出一次中断。

# 4. 计数器/定时器 代码实现

## 4.1 定时器初始化

初始化函数负责设置各种相关的寄存器：

```c
void Timer0_init() {

	// 中断设置
	EA = 1;     // 开启中断系统
	ET0 = 1;    // 允许 Timer0 发出中断

	// 定时器设置
	TR0 = 1;    // Timer0 开启
	TF0 = 0;    // TimerFlag = 0. 这个可能没啥必要设置
	PT0 = 0;    // Timer0 中断优先级，这个没啥意义

	// TMOD 的低 4 bit 置 0001，也就是 Timer0 以模式1 16bit 运行
	TMOD = TMOD & 0xF0;   // 将 TMOD 的低 4 bit 置 0
	TMOD = TMOD | 0x01;   // 将 TMOD 的低 4 bit 置 0001

	// TH0 和 TL0 设置初值 64536 0xFC18
	TH0 = 0xFC;
	TL0 = 0x18;
}
```

全部设置好后，在 main 函数中执行 Timer0_init()，即可开启 Timer0，Timer0 会自动开始自增。

注意这里对 TMOD 的操作，假如其他操作需要用到 Timer1，TMOD 的高 4 bit 已经设置了 Timer1 的模式，就需要用这种办法设置 TMOD 的 低 4 bit 而不破坏高 4 bit。

## 4.2 中断处理函数

TH TL 一旦溢出（TH TL 的初值，每 1000us = 1ms 溢出一次）发出中断，然后 CPU 执行中断处理函数，所以下面这个函数每 1ms 执行一次。

```c
void Timer0_routine() interrupt 1 {
	static int count = 0;

	TH0 = 0xFC;
	TL0 = 0x18;

	if(count == 50) {
		// ....
		count = 0;
	}
}
```

在函数中定义了一个 count = 0，然后每执行一次函数 count ++，加到 50 会进入后面的 if，也就是每 50ms 进入一次 if 后面的处理逻辑，这里就实现了一个 50ms 的循环执行逻辑。

注意 count 用 static 声明，则 count 只初始化一次。count 多次进入不会每次都定义一个 count = 0。